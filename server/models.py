"""SQLAlchemy ORM models for the backend.

The backend stores two main entities:

- :class:`User` with authentication data (nickname + password hash).
- :class:`Profile` with gameplay snapshot (coins/upgrades/stats).

Notes:
    The profile row is auto-created on user creation via an SQLAlchemy
    ``after_insert`` hook.
"""

from datetime import datetime
from typing import Any, Dict

from sqlalchemy import event

from .database import db


class User(db.Model):
    """User account.

    Attributes:
        id: Primary key.
        nickname: Unique nickname used for login/leaderboard.
        password_hash: Hashed password (generated by Werkzeug).
        created_at: UTC timestamp when the user was created.
        profile: One-to-one relationship to :class:`Profile`.
    """
    __tablename__ = "users"

    id = db.Column(db.Integer, primary_key=True)
    nickname = db.Column(db.String(40), unique=True, nullable=False, index=True)
    password_hash = db.Column(db.String(255), nullable=False)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)

    profile = db.relationship(
        "Profile",
        uselist=False,
        back_populates="user",
        cascade="all, delete-orphan",
    )


class Profile(db.Model):
    """User profile snapshot.

    This row stores the latest server-side snapshot of gameplay state.

    Attributes:
        id: Primary key.
        user_id: Foreign key to :class:`User`.
        coins: Integer coin balance.
        upgrades_snapshot: JSON string representing upgrade levels.
        stats_snapshot: JSON string representing aggregated statistics.
        updated_at: UTC timestamp of last update.
        user: Back-reference to :class:`User`.
    """
    __tablename__ = "profiles"

    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey("users.id"), nullable=False, unique=True)
    coins = db.Column(db.Integer, default=0)
    upgrades_snapshot = db.Column(db.Text, default="{}")
    stats_snapshot = db.Column(db.Text, default="{}")
    updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

    user = db.relationship("User", back_populates="profile")

    def to_dict(self) -> Dict[str, Any]:
        """Serialize the profile into a JSON-friendly dictionary.

        Returns:
            Dict[str, Any]: Dictionary with keys ``nickname``, ``coins``,
            ``upgrades``, ``stats``, and ``updatedAt``.

        Notes:
            ``upgrades`` and ``stats`` are returned as the stored JSON strings
            (no parsing is performed in this method).
        """
        return {
            "nickname": self.user.nickname,
            "coins": self.coins,
            "upgrades": self.upgrades_snapshot,
            "stats": self.stats_snapshot,
            "updatedAt": self.updated_at.isoformat() if self.updated_at else None,
        }


@event.listens_for(User, "after_insert")
def create_profile_after_user_insert(mapper, connection, target: User):
    """Create a default profile row immediately after a user is inserted.

    Args:
        mapper: SQLAlchemy mapper (provided by SQLAlchemy).
        connection: SQLAlchemy connection used for the insert.
        target: Newly inserted :class:`User` instance.

    Side Effects:
        Inserts a row into the ``profiles`` table.
    """
    profile_table = Profile.__table__
    connection.execute(
        profile_table.insert().values(user_id=target.id, coins=0, upgrades_snapshot="{}", stats_snapshot="{}")
    )
